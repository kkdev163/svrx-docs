{"./":{"url":"./","title":"关于 svrx","keywords":"","body":"svrx svrx(server-x) 是一个渐进且易于使用的、插件化的前端开发工作台。 作为前端开发，在不同的开发需求下，一般来说我们会有一套或者多套固定的开发环境。 它可能包括本地服务器以及各种用于调试工程的小工具。 维护这样的开发环境是很麻烦的：你不仅需要单独安装每一个工具，还需要对每一个工具进行设置。 此外，针对不同的工程，你还需要有选择地去开启或关闭某个功能。 svrx 做的，就是利用插件机制来整合各种前端开发服务， 让前端开发者可以自由挑选所需的功能，如静态伺服、代理、远程调试等，且无需关心这些功能插件的安装过程。 有了svrx这样一个前端开发工作台，我们可以轻松做到一份配置对应一套开发环境，实现真正的一键启动开发服务。 特性预览 静态伺服 代理 自动重载页面 支持 Hot Reloading 的路由功能 更多的可能： 插件化 安装和使用 你可以在这里阅读使用指南。 官方插件 svrx-plugin-webpack: 提供 webpack 相关功能，编译、hot-reload 等 svrx-plugin-localtunnel: 暴露你的本地服务为公开的外网域名 svrx-plugin-weinre: 基于 weinre，在电脑上远程调试手机页面 svrx-plugin-eruda: 基于 eruda，直接在手机上开启 dev tool 进行调试 svrx-plugin-qrcode: 在页面上或 console 中展示当前页面的二维码 svrx-plugin-markdown: 展示 markdown 类型的文件，提供实时预览、hot-reload、自动滚动定位等功能 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"quick-start.html":{"url":"quick-start.html","title":"快速上手","keywords":"","body":"快速上手 开始使用 svrx 吧！ 安装 svrx 我们推荐使用 cli 工具来管理和使用 svrx， 全局安装 cli 后你将可以在系统的任意地方使用 svrx。 npm install -g @svrx/cli 注意： cli 的作用是安装和加载你指定的svrx版本，这与 cli 本身的版本无关。 @svrx/cli 将安装的 svrx 包存储在 ~/.svrx， 你可以通过设置 SVRX_DIR 环境变量来改变这个存储路径。 用 svrx 启动你的工程 常用指令 @svrx/cli 提供了以下几个常用指令： svrx # 启动svrx服务 svrx serve # 同svrx（serve命令可省略） svrx --version # 查看 cli 及当前使用的 svrx 版本 svrx --help # 命令及参数提示 在工程中使用 svrx 启动服务 开始前，首先你需要进入到你的工程目录，我们假设你的工程中已经有一个 index.html： cd your_project ls # index.html 无需经过任何配置和传参，直接运行serve命令即可开启一个简单的本地服务器： svrx 此时访问 http://localhost:8000 ，就可以看到 index.html 中的内容了。 使用参数 如果需要对 svrx 进行配置，可以通过命令行传参来实现： svrx --port 3000 --https --no-livereload 详细的参数列表可以在这里查看。 配置持久化 当然，你也可以在你的工程目录下建立 .svrxrc.js 或 svrx.config.js 文件，将上面的命令行参数持久化下来： // .svrxrc.js module.exports = { port: 3000, https: true, livereload: false }; 然后直接运行 serve 命令， svrx 会自动读取你的配置。 其它指令 另外，如果你需要关心 svrx 的版本安装情况，或是想安装某个特定的 svrx 版本，那么你还可以使用下面这些指令： svrx ls # 查看所有本地已安装的svrx版本 svrx ls-remote # 查看所有已发布的svrx版本 svrx install # 安装某个的svrx svrx remove # 从本地移除某个的svrx Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"plugin/":{"url":"plugin/","title":"插件体系","keywords":"","body":"插件体系 插件的使用 插件列表 如何写一个插件 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"plugin/usage.html":{"url":"plugin/usage.html","title":"插件的使用","keywords":"","body":"插件的使用 通过命令行 你可以通过命令行的方式去使用插件，例如： svrx --plugin markdown -p qrcode # -p 是 --plugin 的缩写 svrx --markdown --qrcode # 在命令行中设置某个插件名为 true 也可以快速开启一个插件 svrx --plugin \"qrcode?ui=false\" # 可以用 name?querystring 进行插件传参 svrx --plugin \"webpack@0.0.3\" # name@version 可以声明插件版本 通过.svrxrc.js配置 同样的，你也可以通过配置 .svrxrc.js 中的 plugins 字段来启用或配置插件，如： // .svrxrc.js module.exports = { plugins: [ 'markdown', { name: 'qrcode', options: { ui: false, }, }, { name: 'webpack', version: '0.0.3', }, ], }; 然后在项目根目录执行svrx命令， svrx会自动帮你安装markdown，qrcode和webpack插件，并运行它们。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"plugin/contribution.html":{"url":"plugin/contribution.html","title":"如何写一个插件","keywords":"","body":"如何写一个插件 使用svrx-create-plugin帮助你更容易的开发插件 第一个 svrx 插件 让我们实现第一个插件 —— svrx-plugin-hello-world， 它用来在终端和浏览器器端分别打印用户欢迎语 文件结构 └── svrx-plugin-hello-world ├── client.js ├── index.js └── package.json 其实只有package.json 和 index.js是必须的 以下分别做下介绍 package.json { \"name\" : \"svrx-plugin-hello-world\", \"engines\": { \"svrx\" : \"0.0.x\" } ...略.. } 在package.json中只有 2 个字段是 svrx 依赖的 name: 包名要求必须是 svrx-plugin 开头，这是为了方便使用 npm 服务来进行插件查找 engines.svrx: 定义此插件的可运行 svrx 版本，svrx 会自动加载最新的匹配插件， engines.svrx 可以是一个 semver，如0.1.x或~0.1等 - index.js module.exports = { configSchema: { user: { type: 'string', default: 'svrx', description: 'username for hello world' } }, assets: { script: ['./client.js'] }, hooks: { async onCreate({ logger, config }) { logger.log(`Hello ${config.get('user')} from server`); } } }; 其中 configSchema 插件参数定义，请参考参数定义了解更多,这里我们定义了一个默认为'svrx'的字符串类型的参数 user assets: 前端资源配置，他们会被自动注入到前端脚本中 style: css 脚本注入，默认注入 html 头部，本例没有使用 script: script 脚本注入，默认注入 html 尾部 注入前端资源都会被合并成一个资源 hook.onCreate: 插件创建的钩子，在这里我们可以通过注入的服务组件来扩展插件，这里仅介绍使用到的服务 logger: 日志服务 config: 获取用户参数的组件 本例做的是在终端打印关于 user 参数的欢迎语 hook.onCreate 实际上还接受多种组件服务，具体请参考插件服务组件 - client.js 前端注入脚本中有一个「全局变量 svrx」， 挂载了一些 svrx 在前端的内置服务。 这个全局 svrx 仅在插件脚本内部可以访问，不用担心全局污染 const { config } = svrx; config.get('user').then(user => { console.log(`Hello ${user} from browser`); }); 这里我们仅仅是做了一个用户相关控制台 log 输出 与服务端的 config 组件不一样，这里的 config 是通过 websocket 传递的，所以接口返回的是 promise svrx 其实还暴露了其它前端服务，具体请参考前端 API '发布' && 运行 在根目录，我们直接运行npm publish .尝试发布，会发现发布失败了，因为hello-world插件已经被官方发布了。 所以我们跳过这一步，直接运行 svrx -p hello-world 检查下浏览器端和命令行终端将可以看到 'Hello svrx from browser' 的类似日志，说明插件已经生效 也可以通过脚本的方式来启动 const svrx = require('@svrx/svrx'); svrx({ plugins: ['hello-world'] }).start(); 进一步阅读: 如何本地测试? 插件服务 API 所有插件服务都可以在两个地方被注入 插件定义中的hooks.onCreate钩子 module.exports = { hooks: { async onCreate({ middleware, injector, events, router, config, logger, io }) { // use component here } } }; svrx 实例的plugin事件回调，此事件会在所有插件组装完毕后执行 svrx().on('plugin', async ({ logger, io }) => { // use component here }); 接下来，我们依次说明这 7 个组件 middleware middleware 负责添加满足 koa 风格的中间件 完成后端逻辑的注入 - middleware.add(name, definition) 增加一个中间件 Usage middleware.add('hello-world-middleware', { priority: 100, async onRoute(ctx, next) {} }); Param name [String]: 定义一个唯一的中间件名 debug 模式下根据此命名可以 track 请求响应的管线 definition.priority [Number]: 默认为 10. svrx 会根据 priority 由高到低的组装中间件，即请求会先经过高优先级的插件 definition.onRoute [Function]: 满足 koa 规范的中间件定义，如果 definition 是一个函数，则会自动成为 definenition.onRoute - middleware.del(name) 删除一个中间件 Usage middleware.del('hello-world-middleware'); Param name: 传入add的名称 injector injector用来改写响应流或注入前端资源 - injector.add(type, definition) 增加一种注入资源, 目前支持原生的 js 和 css 注入，他们注入规则如下 样式会合并到/svrx/svrx-client.css下，并注入到 html 的head闭合标签前 脚本会合并到/svrx/svrx-client.js，并注入到 html 的body闭合标签前 Usage injector.add('script', { content: ` console.log('hello world') ` }); 上例会往/svrx/svrx-client.js 注入 content 字段中的脚本内容 Param type: 目前仅支持script以及style definition.content [String]: 资源的内容 definition.filename [String]: 资源文件，必须是绝对地址 content 的优先级高于 filename，二者取其一即可 - injector.replace(pattern, replacement) 自定义 html 的替换规则 Usage injector.replace(/svrx/g, 'server-x'); 上例将 html 中的 svrx 替换为 server-x Param pattern [String|RegExp] replacement [String|Function] injector.replace的使用与String.prototype.replace完全一致 资源注入就是通过injector.replace实现的 events 内置事件监听器，支持 async sorted emitter，即可以依次调用监听函数，并可在任意一个事件监听中终止事件传递 - events.on(type, fn) Usage events.on('hello', async payload => {}); events.on('hello', async (payload, ctrl) => { ctrl.stop(); // stop events emit, only works in sorted emit mode }); Param type [String]: 事件名 fn(payload, ctrl): 事件回调，它包含 2 个入参 payload [String]: 事件参数, 通过 emit 传入 ctrl [Object]: 控制器, 调用ctrl.stop()可终止 sorted emit 如果回调返回一个Promise(比如 async function)，视为一个异步回调 - events.emit(type, param, sorted) Usage // sorted emit, handler will be called one by one events.emit('hello', { param1: 'world' }, true).then(() => { console.log('emit is done'); }); // parallel emit events.emit('hello', { param1: 'world' }).then(() => { console.log('emit is done'); }); Param type [String]: 事件名 payload: 事件参数，被on中注册的回调函数接收 sorted [Boolean]: 默认false, 是否串行阻塞的触发事件 Return Promise - events.off(name, handler) Usage events.on('hello'); // remove all hello's handler events.on('hello', handler); // remove specific handler 内置事件 plugin: 当插件准备完毕后触发 file:change: 当文件发生变更时被触发 ready: 当服务启动时触发，如果你需要在服务启动处理部分逻辑(如获取服务端口)，请注册这个事件 config 插件配置管理 - config.get(path) 获取一个插件配置 config 内部维护的数据结构为不变数据，对于配置有实时性要求的，必须使用 config.get 来取值，确保获得最新配置项目 Usage config.get('user'); // get the user param of plugin config.get('user.name'); // get the user.name param of plugin 你也可以获取全局参数，只需要加$.前缀 config.get('$.port'); // get the server's port config.get('$.root'); // get the svrx working directory Param field: 配置名，深层配置用.分割，比如user.name Return 配置值 - config.set(field, value) 设置配置项 Usage config.set('a.b.c', 'hello'); // deep set config.get('a'); // => { b: { c: 'hello' } } Param field: 配置名，深层配置用.分割，比如user.name value 配置值 - config.watch([field, ]handler) 监听配置变化, 配置变化检查会在set、del、splice方法后被触发 config.watch( (evt)=>{ console.log(evt.affect('a.b.c')) => true console.log(evt.affect('a')) // => true console.log(evt.affect('a.c')) // => false }) config.set('a.b.c', 'hello'); Param field: 字段名, field是可选的，如不传入则所有 config 变更都会触发 handler(evt): 监听回调 evt.affect [Function]: 判断本次变更是否影响某字段 - config.del(field) 删除某个配置项 Usage config.del('a.b.c'); config.get('a.b.c'); //=> undefined Param 配置名 - config.splice(field, start[, delCount[, items...]) 数组 splice 的 config 版本 除了field外，其他参数与 Array.prototype.splice 一致 router 从插件层面扩展或注册Routing 模块 - router.route(register) 快捷注册路由，与Routing DSL一致 Usage const {route} = router; route({all, get, post}=>{ all('/blog').to.send('Hi, Blog') get('/user').to.send('Hi, user') post('/user').to.send({code: 200, data: 'Success!'}) }) Param register({...methods}): 注册回调 methods: 对应HTTP methods - router.action(name, builder) 注册一个与 proxy、json 类似的 action Usage const { action } = router; action('hello', user => ctx => { ctx.body = `hello ${user}`; }); route(({ all }) => { all('/blog').hello('svrx'); //=> response 'hello svrx' }); Param name [String]: action 名，即后续的调用方法名 builder(payload) payload: 即传入 action 方法的参数，如上栗的'svrx' Return: builder 返回标准的koa 中间件 - router.load(filename) 手动加载一个 route 文件，与启动参数 route 一致 加载的文件同样支持 hot reloading Usage await router.load('/path/to/route.md'); Param filename: 路由文件文件的绝对路径 Return Promise logger 日志模块，它的分级可以通过logger.level来控制(默认为warn) svrx({ logger: { level: 'error' } }); 或从 cli 端 svrx --logger.level error 上例将会输出warn以上的日志，如notify、error logger[level](msg) svrx 提供了多种级别的日志，分别是slient, notify, error , warn(默认日志分级), info, debug Usage logger.notify('notify'); // show `nofity` logger.error('error'); // show `error` and `notify` logger.warn('warn'); // show `warn`、`error` and `norify` logger.notify 由于会非常常用，所以它有一个 alias logger.log io io 负责插件后端与前端的通信， 请结合 client 端的 io 查看 - io.on( type, handler ) 监听浏览器端发送消息(即通过浏览器端io.emit发送) io.on('hello', payload => { console.log(payload); // =>1 }); Param type: 事件名 handler(payload): 事件回调 payload: 事件参数 - io.emit(type, payload) 发送 io 事件到服务端 Usage client side const { io } = svrx; io.emit('hello', 1); server side hooks: { async onCreate({io}){ io.on('hello', payload=>{ console.log(payload) // =>1 }) } } Param type: 事件名 payload: 事件参数 注意事件参数必须是可序列化的，因为要通过网络传输 - io.off(type[, handler]) 解除监听 Usage io.off('hello'); //=> remove all hello handlers io.off('hello', handler); //=> remove specific handler - io.register(name, handler) 注册一个 io 服务， 它可以在客户端或服务端以io.call的方式调用 Usage io.register('hello.world', async payload => { return `Hello ${payload}`; }); Param name [String]: 服务名，call 中会被使用 handler: 服务逻辑实现，异步请返回 Promise 或使用 async/await - io.call(name, payload) 调用注册的服务 Usage 上例如下调用会返回 'Hello svrx' io.call('hello.world', 'svrx').then(data => { console.log(data); // => Hello svrx }); Param name [String]: 服务名 payload [Any]: 服务入参 Return Promise 客户端 API 客户端 API 统一通过 svrx 全局变量暴露，如下例 const { io, events, config } = svrx; 以下依次说明 io 通信模块，负责与服务端通信 - io.on(type, handler) 监听服务端 io 事件 Usage server side io.emit('hello', 1); client side const { io } = svrx; io.on('hello', payload => { console.log(payload); //=>1 }); 注意后端 io.emit 属于广播，所有前端页面都会收到信息 Param type: 事件名 handler(payload): 事件回调 payload: 事件参数 - io.emit(type, payload) 发送 io 事件到服务端 Usage client side const { io } = svrx; io.emit('hello', 1); server side { hooks: { async onCreate({io}){ io.on('hello', payload=>{ console.log(payload) // =>1 }) } } } Param type: 事件名 payload: 事件参数 注意事件参数必须是可序列化的，因为要通过网络传输 - io.off(type[, handler]) 解除监听 Usage io.off('hello'); //=> remove all hello handlers io.off('hello', handler); //=> remove specific handler - io.call(name, payload) 在 client 端的 io.call 与服务端完全一致，但要确保 payload 是可序列化的,因为会经过网络传输 Usage io.call('hello.world', 'svrx').then(data => { console.log(data); }); Param name [String]: 服务名 payload [Any]: 服务入参 Return Promise events 浏览器端内部的事件发射器，这部分和服务端 events完全一致，不做赘述 Usage const { events } = svrx; events.on('type', handler); events.emit('type', 1); events.off('type'); events 与 io 的不同在于 io 是 服务端与客户端的通信，而 events 是单端的事件触发器 config 客户端的config模块与服务端几乎一致，唯一区别是从同步接口编程了 Promise 化的异步接口(因为 socket 的网络通信) - config.get(field) Usage config.get('$.port').then(port => { // get the server port }); config.get('user').then(port => { //get the param belongs to current plugin }); 注意获取的参数是属于脚本的，如果获取全局请假$.前缀 - config.set、config.splice、config.del 上述三个方法和get一样，与服务端表现一致，不过返回值变为 Promise Usage config.set('a.b', 1).then(() => { config.get('a.b').then(ab => { console.log(ab); // => 1 }); }); 参数定义 svrx 支持一种基于 json-schema 扩展的参数定义，以内部定义的参数为例 Usage module.exports = { root: { type: 'string', default: process.cwd(), description: 'where to start svrx', ui: false }, route: { description: 'the path of routing config file', anyOf: [{ type: 'string' }, { type: 'array' }] }, logger: { description: 'global logger setting', type: 'object', properties: { level: { type: 'string', default: 'error', description: \"set log level, predefined values: 'silent','notify','error','warn', 'debug'\" } } } }; Field 详解 type [String]: JSON-Schema 允许的字段类型 ，可以是array、string、number、boolean、object、null default [Any]: 默认值 required [Boolean]: 是否是必须的, 默认是false properties [Object]: 定义属性，每层属性又是一层 schema 定义 ui: svrx 的扩展字段，是否要在 svrx-ui 中被展示 anyOf: 属性任选其一，如route: { description: 'the path of routing config file', anyOf: [{ type: 'string' }, { type: 'array' }], }, 进一步的 JSON Schema 定义请参考官方文档 如何测试? 不建议大家发布测试插件到 npm, 可以通过以下方式来进行本地测试 svrx({ plugins: [ { name: 'hello-world', path: '/path/to/svrx-plugin-hello-world' } ] }).start(); 指定 path 参数后，svrx 会加载本地包，而不是从 npm 中获取 更容易的插件开发 —— svrx-create-plugin svrx 官方提供的脚手架帮助你更容易的开发和发布你的插件 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"practice/":{"url":"practice/","title":"项目实战","keywords":"","body":"项目实战 特定场景使用 结合主流脚手架使用 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"practice/recipe.html":{"url":"practice/recipe.html","title":"特定场景使用","keywords":"","body":"特定场景使用 由于svrx提供了丰富灵活的插件系统，我们几乎可以在所有开发场景中使用svrx。 这里我们整理了一些svrx及常见插件的使用场景，希望这些配置能对你有帮助。 在静态页面启用服务器 代理 webpack 在移动端开启 eruda dev tool 利用 weinre 进行远程调试 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"practice/integration.html":{"url":"practice/integration.html","title":"结合主流脚手架使用","keywords":"","body":"结合主流脚手架使用 使用 create-react-app 或 vue-cli 初始化项目： # CRA npm init react-app my-app # Vue CLI npm i @vue/cli -g vue create my-app 项目根目录创建文件 webpack.config.js： // CRA module.exports = require('react-scripts/config/webpack.config')('development'); // Vue CLI module.exports = require('@vue/cli-service/webpack.config'); 好了，就这些 &#x1F389; svrx --webpack 结合 插件 使用更香哦 (ˇˍˇ) Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"guide/":{"url":"guide/","title":"进阶指南","keywords":"","body":"进阶指南 Routing 路由的使用 API 列表 Option 列表 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"guide/route.html":{"url":"guide/route.html","title":"Routing 路由的使用","keywords":"","body":"Routing 路由的使用 快速起步 你可通过以下命令来快速尝试 svrx 的动态路由功能 touch route.js # create empty routing file svrx --route route.js 在 route.js 中 get('/blog').to.json({ title: 'svrx' }); 打开 /blog，你将看到 {title: 'svrx'} 的 json 输出 特性 支持 hot reloading ( 通过编辑 route.js 来验证 ) 简单的书写，直观的阅读 支持通过插件来扩展和分发 语法 [method](selector).to.[action](payload) 举个例子 post('/blog').to.proxy('http://music.163.com'); 分别对应 method: post selector: /blog action: proxy payload: 'http://music.163.com' 其中 to 只是一个介词，可以省略 路由 路由方法 svrx 路由支持 methods 定义的 http methods ⚠️ 由于 delete 与 js 保留字冲突，你可以使用 del() 来创建 DELETE 方法 路由匹配 svrx 路由基于 path-to-regexp 匹配, 和两大平民 Node 框架 express 和 koa 相同. 查看 path-to-regexp 来了解更详尽的匹配规则，以下做简要概述 规则解析举例 /svrx/:id: 具名匹配，规则默认为 (\\w+) /svrx/:id(hello|world): 具名且指定匹配规则 /svrx(.*): 不具名匹配 /\\/svrx\\/(.*)$/: 对于复杂规则的路由，也可以直接使用正则表达式 匹配参数 具名匹配如/:id, 可以通过 ctx.params.id 获得 匿名匹配如/(hello|world)/(.*).html，可以通过 ctx.params[0] 以及 ctx.params[1] 依次获得匹配参数 正则匹配如/\\/svrx\\/(.*)$/，ctx.params[i] 依次获得正则的子匹配结果 参数快捷映射 除 Action:handle 外，大部分 action 在语法上不具备操作 koa 上下文( context ) 的能力，部分 action 做了 参数快捷映射 的支持 以 sendFile 为例 get('/html/:path.(html|htm)').to.sendFile('./{path}.{0}') /html/index.html 会发送 ${root}/html/index.html /html/home.htm 会发送 ${root}/html/home.htm Action 清单 你可以使用路由的 插件接口 来扩展 Action send 发送响应内容 get('/blog').to.send({ title: 'this is a blog' }); send 是 koa 框架 ctx.body 的语法糖，当 payload 类型不同时有以下默认行为 string 如果包含以开头的字符比如, Content-Type 头会设置为 text/html, 浏览器会渲染为 html 否则返回text/plain object or array or number or boolean ... 返回 json, Content-Type 为 application/json sendFile 发送文件内容，根据自动文件后缀设置 Content-Type get('/index.html').to.sendFile('./index.html'); 根路径 = serve.base || root ⚠️支持参数映射, 如下例 get('/file/:id.html').to.sendFile('./assets/{id}.html') json 无论 payload 为什么类型，都发送 json 响应 get('/blog').to.json({title: 'svrx'}); redirect(target[, code]) 服务端跳转 target: 目标 path code: http code, default 302 get('/blog').to.redirect('/user'); ⚠️支持参数映射, 如下例 get('/blog/:path(.*)').to.redirect('/user/{path}') header 设置响应头，由于 header 并不发送响应内容，你可以串联其他 action get('/blog') .to.header({ 'X-Engine': 'svrx' }) .json({ code: 200 }); rewrite 路由重写 ⚠️支持参数映射 get('/old/rewrite:path(.*)').to.rewrite('/svrx/{path}') get('/svrx(.*)').to.send('Hello svrx') 则/old/1和/svrx/1 都会返回Hello svrx 由于 rewrite 并不发送响应内容，你也可以串联其他 action proxy(target[, options]) 代理，将 path 代理到 target 服务器。 target: 目标服务器 options: 同 proxy.options changeOrigin secure pathRewrite get('/api(.*)').to.proxy('http://mock.server.com/') get('/test(.*)').to.proxy('http://mock.server.com/', { secure: false, }) get('/test/:id').to.proxy('http://{id}.dynamic.server.com/') handle handle 即定义一个 koa 的中间件，属于全能力 action，以上所有功能都可以使用 handle 来实现， 代价就是可读性的降低. get('/hello-world').to.handle((ctx)=>{ ctx.type = 'html' ctx.body = 'Hello World' }); 尽可能抽取通用能力为自定义 action，请参考「插件接口」小节 插件接口 插件的 hooks.onCreate 会注入名为 router 对象, 包含三个方法 action: 注册一个与 proxy、json 等同级的 action load: 加载一个 routing file route: 脚本式的定义 router 详细请参考 插件开发指南 完整范例文件 get('/handle(.*)').to.handle((ctx) => { ctx.body = 'handle'; }); get('/blog(.*)').to.json({ code: 200 }); get('/code(.*)').to.send('code', 201); get('/json(.*)').to.send({ json: true }); get('/text(.*)').to.send('haha'); get('/html(.*)').to.send('haha'); get('/rewrite:path(.*)').to.rewrite('/query{path}'); get('/redirect:path(.*)').to.redirect('localhost:9002/proxy{path}'); get('/api(.*)').to.proxy('http://mock.server.com/') get('/test(.*)').to.proxy('http://mock.server.com/', { secure: false, }) get('/test/:id').to.proxy('http://{id}.dynamic.server.com/') get('/query(.*)').to.handle((ctx) => { ctx.body = ctx.query; }); get('/header(.*)') .to.header({ 'X-From': 'svrx' }) .json({ user: 'svrx' }); get('/user').to.json({ user: 'svrx' }); get('/sendFile/:path(.*)').to.sendFile('./{path}'); Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"guide/api.html":{"url":"guide/api.html","title":"API 列表","keywords":"","body":"API 索引 svrx(option) 获得 svrx 实例 Usage const svrx = require('@svrx/svrx'); const server = svrx({ port: 8002 }); Param option: 查看 option 索引 Return Svrx 实例 server.start() 启动 Svrx Usage server.start().then(port => { console.log(port); }); Return Promise server.close() Usage server.close().then(() => { console.log('Svrx has closed'); }); Param Return Promise server.reload() 主动刷新浏览器 Usage server.reload(); server.on 绑定事件 内置事件 1. ready 在服务启动时触发 server.on('ready', port => {}); 2. plugin 在 build 插件后触发，与插件开发的hook.onCreate钩子接受同样的参数，请参考插件开发指南 server.on('plugin', async ({io, events, config, router, injector, logger, middleware }=>{ // you logic here })) 3. file:change 在文件变化后触发(必须 livereload 为 true) server.off 解绑事件 server.on('file:change', handler); server.off('file:change', handler); server.emit server.emit('custom-event', { param1: 1 }); Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"guide/option.html":{"url":"guide/option.html","title":"Option 列表","keywords":"","body":"参数列表 root string 启动 svrx 的路径, 默认是当前工作目录。 svrx string 你想使用的 svrx 核心包的版本。默认会使用本地安装的最新版 svrx，如果未安装过，则会安装并使用当前发布过的最新版。 port number 端口号，默认是 8000 https boolean 开启/关闭 https。默认是 false。 route string 指定 routing 配置文件 ，详细说明请点击 routing dsl 详细指南 svrx --route route.js 它支持 hot-reload ，即你可以在不重启 svrx 的情况下更新路由规则 livereload boolean, object 开启/关闭页面自动刷新功能， 默认是开启的。 livereload.exclude string, string[] 设置文件忽略规则，如果文件符合任意匹配的 pattern，那么该文件的内容变动不会触发页面刷新。 serve boolean, object 本地服务器配置 serve.base string 告诉服务器从哪里提供静态文件。 默认情况下，我们会先查找当前工作目录下的文件。 你只需要在你想伺服静态资源的时候设置这个选项。 serve.index string 访问根路径时自动展示的 index 文件的文件名，默认是index.html。 serve.directory boolean 开启/关闭serveIndex middleware， directory默认是开启的。 访问根路径时，如果你的 index 文件不存在，serveIndex middleware可以提供一个目录中文件列表的视图，而不是返回 404。 open boolean, string 是否在 svrx 启动后自动打开浏览器， 默认是自动打开本地地址http://localhost:${port}。 你也可以用open指定需要打开的页面： false: 禁用自动打开浏览器 true: 同 'local' 'local': 打开本地地址，如http://localhost:${port} 'external': 打开外部，http://10.242.111.80:${port}/ ( 根据你的内网 IP ) 'home.html': 同'local/home.html' 打开 http://localhost:${port}/home.html historyApiFallback boolean, object 开启/关闭historyApiFallback middleware，默认是关闭的。 如果你的 app 使用了HTML5 History API，那么你可能需要开启这个选项。 historyApiFallback middleware会在请求 404 后返回index.html页面。 proxy proxy 也支持在 route 文件中动态配置 boolean, object, object[] url 转发配置。 你可以在当前域名下设置proxy，将不同的 url 转发至不同的后端地址。 module.exports = { proxy: { '/api': { target: 'http://you.backend.server.com' } }, } 经过如上配置后，一个/api/path请求会被转发至http://you.backend.server.com/api/path。 你也可以重写路径，就像这样： module.exports = { proxy: { '/api': { target: 'http://you.backend.server.com', pathRewrite: {'^/api' : ''} } }, } 现在你的/api/path请求会被转发至http://you.backend.server.com/path。 如果 target 后端的 HTTPS 服务器的证书是无效的，那么请求默认不会被接收。 你可以配置secure来改变这个默认设置: module.exports = { proxy: { '/api': { target: 'https://you.https.server.com', secure: false } }, } 如果你想同时把多个 path 转发到一个相同的地址，可以试试这样做： module.exports = { proxy: [ { context: ['/api', '/wapi', '/pub'], target: 'http://you.backend.server.com', } ], } 如果你想改变 header 中的 origin 为目标域名，可以试试将changeOrigin设为true： module.exports = { proxy: { '/api': { target: 'https://you.https.server.com', changeOrigin: true } }, } cors boolean, object 开启/关闭跨域资源共享（CORS）支持。 默认 Cors 是开启的。 svrx 依赖koa2-cors做跨域资源工程支持，更多使用方法和参数请阅读koa2-cors 参数文档。 registry string npm源地址，设置此选项后，svrx将从此源下载插件。 默认的registry值是你工作目录下的源地址值，即npm config get registry的结果。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "},"contribution.html":{"url":"contribution.html","title":"贡献指南","keywords":"","body":"贡献指南 Show me your code! svrx 欢迎各种形式的贡献： 代码、issue、文档等等。 你有任何想法或建议，也请一定要告诉我们。 Copyright © 2019, NetEase, Inc. all right reserved，powered by GitbookFile Modify: 2019-10-10 20:56:45 "}}